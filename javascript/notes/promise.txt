why we need promises: In javascript, before promises, we use callbacks to handle asynchronous operations,
but it has a probelm of nesting callbacks called "callback hell" or "callback pyramid"
To solve this probelm , we come across "promises"
Promise:
What is a Promise?
-----------------
A Promise is an object representing the eventual completion (or failure) 
of an asynchronous operation. It's a way to handle asynchronous operations in a more 
elegant way than callbacks.

Promise States:
1. Pending: Initial state, neither fulfilled nor rejected
2. Fulfilled: Operation completed successfully
3. Rejected: Operation failed

Basic Promise Syntax:
--------------------
*/

// Creating a Promise
const basicPromise = new Promise((resolve, reject) => {
    // Async operation here
    const success = true;
    
    if (success) {
        resolve("Operation successful!");
    } else {
        reject("Operation failed!");
    }
});

// Using the Promise
basicPromise
    .then(result => console.log(result))
    .catch(error => console.log(error));

/*
Real-World Example 1: User Authentication
---------------------------------------
One of the most common use cases for promises is handling user authentication
*/

const userLogin = (username, password) => {
    return new Promise((resolve, reject) => {
        // Simulating API call delay
        setTimeout(() => {
            if (username === "user123" && password === "pass123") {
                resolve({
                    userId: 1,
                    username: username,
                    token: "abc123xyz"
                });
            } else {
                reject("Invalid credentials");
            }
        }, 1500);
    });
};

// Usage
userLogin("user123", "pass123")
    .then(userData => console.log("Login successful:", userData))
    .catch(error => console.log("Login failed:", error));

/*
Real-World Example 2: Fetching Data from API
------------------------------------------
Promises are extensively used in API calls using fetch
*/

// Example using fetch (which returns a Promise)
fetch('https://api.example.com/data')
    .then(response => response.json())
    .then(data => console.log(data))
    .catch(error => console.log('Error:', error));

/*
Real-World Example 3: File Upload
--------------------------------
Handling file uploads with progress tracking
*/

const uploadFile = (file) => {
    return new Promise((resolve, reject) => {
        // Simulating file upload
        let progress = 0;
        const interval = setInterval(() => {
            progress += 20;
            console.log(`Upload progress: ${progress}%`);
            
            if (progress === 100) {
                clearInterval(interval);
                resolve("File uploaded successfully!");
            }
            
            if (file.size > 5000000) { // 5MB
                clearInterval(interval);
                reject("File too large!");
            }
        }, 500);
    });
};

/*
Real-World Example 4: Loading Resources
-------------------------------------
Loading multiple resources (images, scripts, etc.)
*/

const loadImage = (url) => {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = () => reject(`Failed to load image: ${url}`);
        img.src = url;
    });
};
Example of Promise Chaining vs Nesting:
*/

// BAD (Promise Nesting)
fetchUser(userId)
    .then(user => {
        fetchUserPosts(user.id)
            .then(posts => {
                fetchPostComments(posts[0].id)
                    .then(comments => {
                        console.log(comments);
                    });
            });
    });

// GOOD (Promise Chaining)
fetchUser(userId)
    .then(user => fetchUserPosts(user.id))
    .then(posts => fetchPostComments(posts[0].id))
    .then(comments => console.log(comments))
    .catch(error => console.log(error));
Remember:
1. Promises are great for handling asynchronous operations
2. They help avoid callback hell
3. They provide better error handling
4. They can be chained for sequential async operations
5. They work well with modern async/await syntax